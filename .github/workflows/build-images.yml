name: Build Docker Images

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      custom_model:
        description: 'Custom model ID to build (optional)'
        required: false
        type: string
      custom_tag:
        description: 'Custom tag suffix (e.g., "my-model" creates "my-model-latest")'
        required: false
        type: string
        default: 'custom'
      hf_token_required:
        description: 'Does this model require HF token?'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Define the build matrices
  setup:
    runs-on: ubuntu-latest
    outputs:
      base_matrix: ${{ steps.matrix.outputs.base_matrix }}
      model_matrix: ${{ steps.matrix.outputs.model_matrix }}
      manifests: ${{ steps.matrix.outputs.manifests }}
      custom_model: ${{ steps.custom.outputs.model }}
      date_tag: ${{ steps.date.outputs.date }}
    steps:
      - name: Set date tag
        id: date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

      - name: Set build matrices
        id: matrix
        env:
          REGISTRY: ghcr.io
          IMAGE_NAME: ${{ github.repository }}
        run: |
          # Lowercase the image name (Docker requires lowercase)
          IMAGE_NAME_LOWER=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
          # Define models, dockerfiles, and architectures
          MODELS='[
            {"model_id":"google/gemma-3-270m-it","requires_token":true,"tag_suffix":"gemma-3-270m-it"},
            {"model_id":"google/gemma-3-4b-it","requires_token":true,"tag_suffix":"gemma-3-4b-it"},
            {"model_id":"meta-llama/Llama-3.2-1B-Instruct","requires_token":true,"tag_suffix":"llama-3.2-1b"},
            {"model_id":"meta-llama/Llama-3.1-8B-Instruct","requires_token":true,"tag_suffix":"llama-3.1-8b"},
            {"model_id":"Qwen/Qwen3-4B","requires_token":false,"tag_suffix":"qwen3-4b"},
            {"model_id":"Qwen/Qwen3-0.6B","requires_token":false,"tag_suffix":"qwen3-0.6b"},
            {"model_id":"Qwen/Qwen3-8B","requires_token":false,"tag_suffix":"qwen3-8b"},
            {"model_id":"Qwen/Qwen3-14B","requires_token":false,"tag_suffix":"qwen3-14b"}
          ]'
          # Define dockerfile + architecture combinations
          # Default Dockerfile: amd64 only
          # PT25 Dockerfile: amd64 and arm64
          DOCKERFILE_ARCHS='[
            {"dockerfile":"Dockerfile","base_tag":"base","tag_variant":"","arch":"amd64","platform":"linux/amd64","runs_on":"ubuntu-latest-l"},
            {"dockerfile":"Dockerfile.pt25","base_tag":"base-pt25","tag_variant":"-pt25","arch":"amd64","platform":"linux/amd64","runs_on":"ubuntu-latest-l"},
            {"dockerfile":"Dockerfile.pt25","base_tag":"base-pt25","tag_variant":"-pt25","arch":"arm64","platform":"linux/arm64","runs_on":"ubuntu-latest-l-arm"}
          ]'

          # Base image matrix: 3 builds (1 for default + 2 for pt25)
          BASE_MATRIX=$(jq -c -n --argjson dockerfile_archs "$DOCKERFILE_ARCHS" '
            [
              $dockerfile_archs[] |
              {
                dockerfile: .dockerfile,
                tag_suffix: (.base_tag + "-" + .arch),
                platform: .platform,
                runs_on: .runs_on,
                arch: .arch
              }
            ]
          ')
          echo "base_matrix=${BASE_MATRIX}" >> $GITHUB_OUTPUT

          # Model image matrix: Models × Dockerfile/Arch combinations (24 builds)
          # Each entry includes the base_image reference
          MODEL_MATRIX=$(jq -c -n \
            --argjson models "$MODELS" \
            --argjson dockerfile_archs "$DOCKERFILE_ARCHS" \
            --arg registry "$REGISTRY" \
            --arg image_name "$IMAGE_NAME_LOWER" '
            [
              $models[] as $model |
              $dockerfile_archs[] as $da |
              {
                model_id: $model.model_id,
                requires_token: $model.requires_token,
                base_tag: ($model.tag_suffix + $da.tag_variant),
                tag_suffix: ($model.tag_suffix + $da.tag_variant + "-" + $da.arch),
                base_image: ($registry + "/" + $image_name + ":" + $da.base_tag + "-" + $da.arch + "-latest"),
                platform: $da.platform,
                runs_on: $da.runs_on,
                arch: $da.arch
              }
            ]
          ')
          echo "model_matrix=${MODEL_MATRIX}" >> $GITHUB_OUTPUT

          # Manifests for pt25 (multi-arch) - default dockerfile is single-arch so no manifest needed
          MANIFESTS=$(jq -c -n --argjson models "$MODELS" '
            [
              $models[] as $model |
              {
                base_tag: ($model.tag_suffix + "-pt25")
              }
            ]
          ')
          echo "manifests=${MANIFESTS}" >> $GITHUB_OUTPUT

      - name: Set custom model
        id: custom
        run: |
          if [ -n "${{ inputs.custom_model }}" ]; then
            TAG_SUFFIX="${{ inputs.custom_tag }}"
            if [ -z "$TAG_SUFFIX" ]; then
              TAG_SUFFIX="custom"
            fi
            CUSTOM_MODEL='{"model_id":"${{ inputs.custom_model }}","requires_token":${{ inputs.hf_token_required }},"tag_suffix":"'$TAG_SUFFIX'"}'
            echo "model=${CUSTOM_MODEL}" >> $GITHUB_OUTPUT
          else
            echo "model=" >> $GITHUB_OUTPUT
          fi

  # Stage 1: Build base images (4 builds: 2 Dockerfiles × 2 architectures)
  build-base-images:
    if: github.event_name == 'push'
    needs: setup
    strategy:
      matrix:
        build: ${{ fromJson(needs.setup.outputs.base_matrix) }}
      fail-fast: false
    uses: ./.github/workflows/build-base-image.yml
    with:
      dockerfile: ${{ matrix.build.dockerfile }}
      tag_suffix: ${{ matrix.build.tag_suffix }}
      date_tag: ${{ needs.setup.outputs.date_tag }}
      runs_on: ${{ matrix.build.runs_on }}
      platform: ${{ matrix.build.platform }}

  # Stage 2: Build model images (32 builds, but fast - just downloads models)
  build-model-images:
    if: github.event_name == 'push'
    needs: [setup, build-base-images]
    strategy:
      matrix:
        build: ${{ fromJson(needs.setup.outputs.model_matrix) }}
      fail-fast: false
    uses: ./.github/workflows/build-single-image.yml
    with:
      model_id: ${{ matrix.build.model_id }}
      tag_suffix: ${{ matrix.build.tag_suffix }}
      date_tag: ${{ needs.setup.outputs.date_tag }}
      requires_token: ${{ matrix.build.requires_token }}
      base_image: ${{ matrix.build.base_image }}
      runs_on: ${{ matrix.build.runs_on }}
      platform: ${{ matrix.build.platform }}
    secrets:
      hf_token: ${{ secrets.HF_TOKEN }}

  # Stage 3: Create multi-arch manifests after all model builds complete
  create-manifests:
    if: github.event_name == 'push'
    needs: [setup, build-model-images]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        manifest: ${{ fromJson(needs.setup.outputs.manifests) }}
      fail-fast: false
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        env:
          BASE_TAG: ${{ matrix.manifest.base_tag }}
          DATE_TAG: ${{ needs.setup.outputs.date_tag }}
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"

          # Create manifest for -latest tag
          docker manifest create ${IMAGE}:${BASE_TAG}-latest \
            ${IMAGE}:${BASE_TAG}-amd64-latest \
            ${IMAGE}:${BASE_TAG}-arm64-latest
          docker manifest push ${IMAGE}:${BASE_TAG}-latest

          # Create manifest for date tag
          docker manifest create ${IMAGE}:${BASE_TAG}-${DATE_TAG} \
            ${IMAGE}:${BASE_TAG}-amd64-${DATE_TAG} \
            ${IMAGE}:${BASE_TAG}-arm64-${DATE_TAG}
          docker manifest push ${IMAGE}:${BASE_TAG}-${DATE_TAG}

          echo "Created multi-arch manifests for ${BASE_TAG}"

      - name: Generate manifest summary
        run: |
          echo "## Manifest Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Base Tag:** ${{ matrix.manifest.base_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Multi-arch Tags:** ${{ matrix.manifest.base_tag }}-latest, ${{ matrix.manifest.base_tag }}-${{ needs.setup.outputs.date_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Architectures:** amd64, arm64" >> $GITHUB_STEP_SUMMARY

  # Build custom model (only on manual dispatch) - uses default base image
  build-custom:
    if: github.event_name == 'workflow_dispatch' && inputs.custom_model != ''
    needs: setup
    uses: ./.github/workflows/build-single-image.yml
    with:
      model_id: ${{ fromJson(needs.setup.outputs.custom_model).model_id }}
      tag_suffix: ${{ fromJson(needs.setup.outputs.custom_model).tag_suffix }}
      date_tag: ${{ needs.setup.outputs.date_tag }}
      requires_token: ${{ fromJson(needs.setup.outputs.custom_model).requires_token }}
      base_image: ghcr.io/${{ github.repository }}:base-amd64-latest
    secrets:
      hf_token: ${{ secrets.HF_TOKEN }}
