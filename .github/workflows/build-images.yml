name: Build Docker Images

on:
  push:
    branches: ['**']  # Support all branches
  workflow_dispatch:
    inputs:
      custom_model:
        description: 'Custom model ID to build (optional)'
        required: false
        type: string
      custom_tag:
        description: 'Custom tag suffix (e.g., "my-model" creates "my-model-latest")'
        required: false
        type: string
        default: 'custom'
      hf_token_required:
        description: 'Does this model require HF token?'
        required: false
        type: boolean
        default: false
      build_all_models:
        description: 'Build all predefined models (only works on push or main branch)'
        required: false
        type: boolean
        default: false

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Define the build matrices
  setup:
    runs-on: ubuntu-latest
    outputs:
      base_matrix: ${{ steps.matrix.outputs.base_matrix }}
      model_matrix: ${{ steps.matrix.outputs.model_matrix }}
      manifests: ${{ steps.matrix.outputs.manifests }}
      custom_model: ${{ steps.custom.outputs.model }}
      date_tag: ${{ steps.date.outputs.date }}
      image_name_lower: ${{ steps.matrix.outputs.image_name_lower }}
      branch_name: ${{ steps.matrix.outputs.branch_name }}
      branch_suffix: ${{ steps.matrix.outputs.branch_suffix }}
      should_build_all: ${{ steps.matrix.outputs.should_build_all }}
    steps:
      - name: Set date tag
        id: date
        run: echo "date=$(date +'%Y%m%d')" >> $GITHUB_OUTPUT

      - name: Set branch info and build matrices
        id: matrix
        env:
          REGISTRY: ghcr.io
          IMAGE_NAME: ${{ github.repository }}
        run: |
          # Get branch name
          BRANCH_NAME="${{ github.ref_name }}"
          
          # Convert branch name to lowercase and sanitize (Docker tag restrictions)
          BRANCH_NAME_LOWER=$(echo "$BRANCH_NAME" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          
          # Create branch suffix (empty for main, otherwise -branch-name)
          if [ "$BRANCH_NAME_LOWER" = "main" ] || [ "$BRANCH_NAME_LOWER" = "master" ]; then
            BRANCH_SUFFIX=""
            SHOULD_BUILD_ALL="true"
          else
            BRANCH_SUFFIX="-${BRANCH_NAME_LOWER}"
            # Build all models on push events (any branch) or if explicitly requested via workflow_dispatch
            if [ "${{ github.event_name }}" == "push" ]; then
              SHOULD_BUILD_ALL="true"
            elif [ "${{ inputs.build_all_models }}" == "true" ]; then
              SHOULD_BUILD_ALL="true"
            else
              SHOULD_BUILD_ALL="false"
            fi
          fi
          
          # Debug output
          echo "Event: ${{ github.event_name }}"
          echo "Branch: $BRANCH_NAME -> $BRANCH_NAME_LOWER"
          echo "Branch Suffix: $BRANCH_SUFFIX"
          echo "Should Build All: $SHOULD_BUILD_ALL"
          
          echo "branch_name=${BRANCH_NAME_LOWER}" >> $GITHUB_OUTPUT
          echo "branch_suffix=${BRANCH_SUFFIX}" >> $GITHUB_OUTPUT
          echo "should_build_all=${SHOULD_BUILD_ALL}" >> $GITHUB_OUTPUT
          
          # Lowercase the image name (Docker requires lowercase)
          IMAGE_NAME_LOWER=$(echo "$IMAGE_NAME" | tr '[:upper:]' '[:lower:]')
          echo "image_name_lower=${IMAGE_NAME_LOWER}" >> $GITHUB_OUTPUT
          
          echo "Branch: ${BRANCH_NAME} -> ${BRANCH_NAME_LOWER}, Suffix: ${BRANCH_SUFFIX}, Build All: ${SHOULD_BUILD_ALL}"
          # Define models, dockerfiles, and architectures
          MODELS='[
            {"model_id":"google/gemma-3-270m-it","requires_token":true,"tag_suffix":"gemma-3-270m-it"},
            {"model_id":"google/gemma-3-4b-it","requires_token":true,"tag_suffix":"gemma-3-4b-it"},
            {"model_id":"meta-llama/Llama-3.2-1B-Instruct","requires_token":true,"tag_suffix":"llama-3.2-1b"},
            {"model_id":"meta-llama/Llama-3.1-8B-Instruct","requires_token":true,"tag_suffix":"llama-3.1-8b"},
            {"model_id":"hugging-quants/Meta-Llama-3.1-8B-Instruct-AWQ-INT4","requires_token":false,"tag_suffix":"llama-3.1-8b-awq"},
            {"model_id":"Qwen/Qwen3-4B","requires_token":false,"tag_suffix":"qwen3-4b"},
            {"model_id":"Qwen/Qwen3-0.6B","requires_token":false,"tag_suffix":"qwen3-0.6b"},
            {"model_id":"Qwen/Qwen3-8B","requires_token":false,"tag_suffix":"qwen3-8b"},
            {"model_id":"Qwen/Qwen3-14B","requires_token":false,"tag_suffix":"qwen3-14b"}
          ]'
          # Define dockerfile + architecture combinations
          # Default Dockerfile: amd64 only
          # PT25 Dockerfile: amd64 (pytorch base) and arm64 (nvidia vllm base)
          DOCKERFILE_ARCHS='[
            {"dockerfile":"Dockerfile","base_tag":"base","tag_variant":"","arch":"amd64","platform":"linux/amd64","runs_on":"ubuntu-latest-l"},
            {"dockerfile":"Dockerfile.pt25","base_tag":"base-pt25","tag_variant":"-pt25","arch":"amd64","platform":"linux/amd64","runs_on":"ubuntu-latest-l"},
            {"dockerfile":"Dockerfile.pt25-arm","base_tag":"base-pt25","tag_variant":"-pt25","arch":"arm64","platform":"linux/arm64","runs_on":"ubuntu-latest-l-arm"}
          ]'

          # Base image matrix: 3 builds (1 for default + 2 for pt25)
          BASE_MATRIX=$(jq -c -n \
            --argjson dockerfile_archs "$DOCKERFILE_ARCHS" \
            --arg branch_suffix "$BRANCH_SUFFIX" '
            [
              $dockerfile_archs[] |
              {
                dockerfile: .dockerfile,
                tag_suffix: (.base_tag + "-" + .arch + $branch_suffix),
                platform: .platform,
                runs_on: .runs_on,
                arch: .arch
              }
            ]
          ')
          echo "base_matrix=${BASE_MATRIX}" >> $GITHUB_OUTPUT

          # Model image matrix: Models × Dockerfile/Arch combinations (24 builds)
          # Each entry includes the base_image reference
          MODEL_MATRIX=$(jq -c -n \
            --argjson models "$MODELS" \
            --argjson dockerfile_archs "$DOCKERFILE_ARCHS" \
            --arg registry "$REGISTRY" \
            --arg image_name "$IMAGE_NAME_LOWER" \
            --arg branch_suffix "$BRANCH_SUFFIX" '
            [
              $models[] as $model |
              $dockerfile_archs[] as $da |
              {
                model_id: $model.model_id,
                requires_token: $model.requires_token,
                base_tag: ($model.tag_suffix + $da.tag_variant + $branch_suffix),
                tag_suffix: ($model.tag_suffix + $da.tag_variant + "-" + $da.arch + $branch_suffix),
                base_image: ($registry + "/" + $image_name + ":" + $da.base_tag + "-" + $da.arch + $branch_suffix + "-latest"),
                platform: $da.platform,
                runs_on: $da.runs_on,
                arch: $da.arch
              }
            ]
          ')
          echo "model_matrix=${MODEL_MATRIX}" >> $GITHUB_OUTPUT

          # Manifests for pt25 (multi-arch) - default dockerfile is single-arch so no manifest needed
          MANIFESTS=$(jq -c -n \
            --argjson models "$MODELS" \
            --arg branch_suffix "$BRANCH_SUFFIX" '
            [
              $models[] as $model |
              {
                base_tag: ($model.tag_suffix + "-pt25" + $branch_suffix)
              }
            ]
          ')
          echo "manifests=${MANIFESTS}" >> $GITHUB_OUTPUT

      - name: Set custom model
        id: custom
        run: |
          if [ -n "${{ inputs.custom_model }}" ]; then
            TAG_SUFFIX="${{ inputs.custom_tag }}"
            if [ -z "$TAG_SUFFIX" ]; then
              TAG_SUFFIX="custom"
            fi
            CUSTOM_MODEL='{"model_id":"${{ inputs.custom_model }}","requires_token":${{ inputs.hf_token_required }},"tag_suffix":"'$TAG_SUFFIX'"}'
            echo "model=${CUSTOM_MODEL}" >> $GITHUB_OUTPUT
          else
            echo "model=" >> $GITHUB_OUTPUT
          fi

  # Stage 1: Build base images (4 builds: 2 Dockerfiles × 2 architectures)
  # This runs on push to any branch (when should_build_all is true)
  build-base-images:
    if: needs.setup.outputs.should_build_all == 'true'
    needs: setup
    strategy:
      matrix:
        build: ${{ fromJson(needs.setup.outputs.base_matrix) }}
      fail-fast: false
    uses: ./.github/workflows/build-base-image.yml
    with:
      dockerfile: ${{ matrix.build.dockerfile }}
      tag_suffix: ${{ matrix.build.tag_suffix }}
      date_tag: ${{ needs.setup.outputs.date_tag }}
      runs_on: ${{ matrix.build.runs_on }}
      platform: ${{ matrix.build.platform }}

  # Stage 2: Build model images (32 builds, but fast - just downloads models)
  build-model-images:
    if: needs.setup.outputs.should_build_all == 'true'
    needs: [setup, build-base-images]
    strategy:
      matrix:
        build: ${{ fromJson(needs.setup.outputs.model_matrix) }}
      fail-fast: false
    uses: ./.github/workflows/build-single-image.yml
    with:
      model_id: ${{ matrix.build.model_id }}
      tag_suffix: ${{ matrix.build.tag_suffix }}
      date_tag: ${{ needs.setup.outputs.date_tag }}
      requires_token: ${{ matrix.build.requires_token }}
      base_image: ${{ matrix.build.base_image }}
      runs_on: ${{ matrix.build.runs_on }}
      platform: ${{ matrix.build.platform }}
    secrets:
      hf_token: ${{ secrets.HF_TOKEN }}

  # Stage 3: Create multi-arch manifests after all model builds complete
  create-manifests:
    if: needs.setup.outputs.should_build_all == 'true'
    needs: [setup, build-model-images]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        manifest: ${{ fromJson(needs.setup.outputs.manifests) }}
      fail-fast: false
    steps:
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        env:
          BASE_TAG: ${{ matrix.manifest.base_tag }}
          DATE_TAG: ${{ needs.setup.outputs.date_tag }}
        run: |
          IMAGE="${{ env.REGISTRY }}/${{ needs.setup.outputs.image_name_lower }}"

          # Create manifest for -latest tag
          docker manifest create ${IMAGE}:${BASE_TAG}-latest \
            ${IMAGE}:${BASE_TAG}-amd64-latest \
            ${IMAGE}:${BASE_TAG}-arm64-latest
          docker manifest push ${IMAGE}:${BASE_TAG}-latest

          # Create manifest for date tag
          docker manifest create ${IMAGE}:${BASE_TAG}-${DATE_TAG} \
            ${IMAGE}:${BASE_TAG}-amd64-${DATE_TAG} \
            ${IMAGE}:${BASE_TAG}-arm64-${DATE_TAG}
          docker manifest push ${IMAGE}:${BASE_TAG}-${DATE_TAG}

          echo "Created multi-arch manifests for ${BASE_TAG}"

      - name: Generate manifest summary
        run: |
          echo "## Manifest Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Base Tag:** ${{ matrix.manifest.base_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Multi-arch Tags:** ${{ matrix.manifest.base_tag }}-latest, ${{ matrix.manifest.base_tag }}-${{ needs.setup.outputs.date_tag }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Architectures:** amd64, arm64" >> $GITHUB_STEP_SUMMARY

  # Build custom model (only on manual dispatch) - uses main branch base image (always exists)
  build-custom:
    if: github.event_name == 'workflow_dispatch' && inputs.custom_model != ''
    needs: setup
    uses: ./.github/workflows/build-single-image.yml
    with:
      model_id: ${{ fromJson(needs.setup.outputs.custom_model).model_id }}
      tag_suffix: ${{ fromJson(needs.setup.outputs.custom_model).tag_suffix }}${{ needs.setup.outputs.branch_suffix }}
      date_tag: ${{ needs.setup.outputs.date_tag }}
      requires_token: ${{ fromJson(needs.setup.outputs.custom_model).requires_token }}
      # Always use main branch base image for custom builds (it's guaranteed to exist)
      base_image: ghcr.io/${{ needs.setup.outputs.image_name_lower }}:base-amd64-latest
    secrets:
      hf_token: ${{ secrets.HF_TOKEN }}
